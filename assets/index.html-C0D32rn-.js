import{_ as s,c as n,a as t,o as m}from"./app-_O7WQDmY.js";const e="/algorithm/geometry/scanning/scanning.svg",p={};function o(l,a){return m(),n("div",null,[...a[0]||(a[0]=[t('<h2 id="intro" tabindex="-1"><a class="header-anchor" href="#intro"><span><em>Intro</em></span></a></h2><p>一般运用在图形上，例如求矩形的面积并。<br> 具体来看就跟它的名字一样，一条线在坐标轴上扫。</p><h2 id="2d" tabindex="-1"><a class="header-anchor" href="#2d"><span>二维矩形面积并问题</span></a></h2><p>在一个平面直角坐标系内，给定矩形左下和右上两个点，求多个矩形的面积并。<br><img src="'+e+'" alt="扫描线原理示意图" loading="lazy" width="576" height="420"><br> 像这幅图一样，按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 排序后实际只需要直到被分割出来的条的长度，可以使用线段树维护（<strong>可能需要离散化</strong>）。<br> 每次讲矩形左边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>，右边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，最后查询 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\\sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 所有值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的位置即可。<br> 具体的，需要维护 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span></span> 表示<strong>当前区间</strong>被覆盖的次数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span></span></span></span> 表示当前区间被覆盖的长度。<br> 容易发现，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">cnt&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 时当前区间被覆盖的长度就是<strong>当前区间的长度</strong>。<br> 若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">cnt=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 则区间被覆盖长度为左右儿子的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span></span></span></span> 的和。</p><p>但这并不好维护，并且效率很低，因为每次都要查询根节点，考虑优化。</p><ul><li>由于每个操作都成对出现，所以在 <code>modify</code> 中的 <code>pushdown</code> 并没有作用。<br> 对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 操作且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cnt=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，我们事实上需要用左右两个节点的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span></span></span></span>，但这个时候尽管不维护 <code>pushdown</code> 它们的值也是正确的。</li><li>由于<strong>只需要保证根节点信息正确</strong>，所以压根不会运行到分裂时使用的 <code>pushdown</code>。</li></ul><p>综上，我们可以直接丢掉 <code>pushdown</code>，然后就可以直接做了。</p>',7)])])}const r=s(p,[["render",o]]),c=JSON.parse('{"path":"/algorithm/geometry/scanning/","title":"扫描线 | 算法","lang":"zh-CN","frontmatter":{"title":"扫描线","createTime":"2025/12/27 20:35:48","permalink":"/algorithm/geometry/scanning/","description":"Intro 一般运用在图形上，例如求矩形的面积并。 具体来看就跟它的名字一样，一条线在坐标轴上扫。 二维矩形面积并问题 在一个平面直角坐标系内，给定矩形左下和右上两个点，求多个矩形的面积并。 扫描线原理示意图 像这幅图一样，按 x 排序后实际只需要直到被分割出来的条的长度，可以使用线段树维护（可能需要离散化）。 每次讲矩形左边 +1，右边 −1，最后查...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"扫描线\\",\\"image\\":[\\"https://lyrgo.github.io/algorithm/geometry/scanning/scanning.svg\\"],\\"dateModified\\":\\"2025-12-27T13:09:47.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://lyrgo.github.io/algorithm/geometry/scanning/"}],["meta",{"property":"og:site_name","content":"lyrgo"}],["meta",{"property":"og:title","content":"扫描线"}],["meta",{"property":"og:description","content":"Intro 一般运用在图形上，例如求矩形的面积并。 具体来看就跟它的名字一样，一条线在坐标轴上扫。 二维矩形面积并问题 在一个平面直角坐标系内，给定矩形左下和右上两个点，求多个矩形的面积并。 扫描线原理示意图 像这幅图一样，按 x 排序后实际只需要直到被分割出来的条的长度，可以使用线段树维护（可能需要离散化）。 每次讲矩形左边 +1，右边 −1，最后查..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://lyrgo.github.io/algorithm/geometry/scanning/scanning.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-27T13:09:47.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-27T13:09:47.000Z"}]]},"git":{"createdTime":1766840987000,"updatedTime":1766840987000,"contributors":[{"name":"lyrgo","username":"lyrgo","email":"3572691603@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/lyrgo?v=4","url":"https://github.com/lyrgo"}]},"autoDesc":true,"filePathRelative":"algorithm/geometry/scanning.md","headers":[]}');export{r as comp,c as data};
