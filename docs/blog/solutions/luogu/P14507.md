---
title: P14507 缺零分治 mexdnc
createTime: 2025/11/15 16:34:54
permalink: /blog/slz31tja/
tags:
    - 贪心
---

## 题目大意  

[题目传送门](https://www.luogu.com.cn/problem/P14507)

给定正整数 $n$ 和 $n$ 个二元组 $(b_i,a_i)$，表示有 $b_i$ 个大小为 $a_i$ 的数。  
定义 $\text{mex}$ 表示一个集合中最小未出现的自然数。  
你需要将这 $\sum_{i=1}^{n}b_i$ 个数分为 $k(k\geq 1)$ 个可重集合，使得这 $k$ 个集合的 $\text{mex}$ 和**恰好**为 $m$，求 $k$ 的最小值。  
给定 $T$ 组询问，每次给定一个 $m$，求最小的 $k$，若无解则输出 $-1$。

数据范围：  
$1\leq T\leq 10$  
$1\leq n,q\leq 10^5$  
$0\leq a_i\leq 10^9$ 且 $a_i<a_{i+1}$  
$1\leq b_i\leq 10^9$  
$1\leq m\leq 10^{18}$

## _Solution_

很容易注意到有些 $a_i$ 是没有用的，我们考虑如何将其去除。  
从题目中可以发现，$a_i$ 是升序给我们的，那么有用的 $a_i$ 一定是形如 ${0,1,...,x}$ 的一个排列。  
::: tip 结论
找到最小的 $i$ 使得 $a_i+1\neq a_{i+1}$（若不存在则 $i$ 为 $n$），则 $a_{i+1}$ 到 $a_n$ 都没有用
:::
我们令 $n$ 为上面的 $i$。
于是问题变成了对于 $i\in [1,n]$，有 $b_i$ 个 $i-1$。

---

先来考虑**无解**的情况，分讨一下有两种：
1. $m=0$，若 $n=0$，那么一定有一个集合被分到 $0$，即 $\text{mex}\geq 1$，总和一定不是 $0$，无解。  
2. 令目前所有数能凑出来的 $\text{mex}$ 的和的最大值为 $x$，若 $m>x$，则无解。  

---

考虑怎么求**最大和**：
* 一个集合中的所有数当且仅当出现一次，否则多余的数不产生贡献。
* 如果可以组成一个 $[0,u-1]$ 的序列，那么将其拆分为 $[0,v-1](v < u)$ 一定不优，因为 $[v,u-1]$ 被浪费了。

所以我们只需要每次找到**最大的** $u$ 满足可以构成 $[0,u-1]$ 的一个序列，产生 $u$ 的贡献，重复这个步骤就能得到最大值。

考虑怎么进行代码实现，我们令 $f_i=\min_{j=1}^{i}b_j$，$g_i$ 为最小的满足 $b_j=f_i$ 的 $j$。
进行如下步骤：
1.  ==初始化==  
    初始时令 $p=n$，$d=0$（$p$ 为上面最大的 $u$，$d$ 为删掉的 $0$ 的个数）  
    由于删掉的 $0$ 的数其实就是序列总数，所以 $d$ 就是删除的序列数。
2.  ==计算贡献==  
    令 $c=f_p-d$ 即为能够取出多少个 $[0,p-1]$ 的序列，产生的贡献就是 $p\times c$。
3.  ==更新变量==  
    拿出 $c$ 个序列后，$d\leftarrow d+c$。  
    这个时候的 $g_p-1$ 已经用完（$g_p$ 在原数组对应 $g_p-1$ 这个数），所以 $g_p-1$ 到 $p-1$ 之间剩的数都没有用了，令 $p\leftarrow g_p-1$（注意这个时候指的是下标）
4.  ==完成==  
    重复这个步骤，直到 $p=0$。

这样我们得到了最大值。

::: details 如何计算 $f$ 和 $g$？
很明显要考虑递推。  
如果当前位置 $i$ 的 $b_i<f_{i-1}$，那么 $f_i=b_i$，$g_i=i$。  
如果当前位置 $i$ 的 $b_i\geq f_{i-1}$，那么 $f_i=f_{i-1}$，$g_i=g_{i-1}$
:::

这样，我们成功处理了无解的情况。

---

当前情况一定有解。  
我们把所有构成最大值的数组存下来，记作 $e$，则 $e_i$ 代表一个 $[0,e_i-1]$ 的序列。  
同时，为了用尽量少的集合，我们应该尽可能选择 $\text{mex}$ 大的集合。  
怎么选呢？事实上，$e_i$ 为**单调不增**的。  
这样就好办了，只需要每次找到一个 $i$ 满足 $\sum_{j=1}^i e_i\leq m$ 且 $\sum_{j=1}^{i+1} e_i>m$，则为了凑 $m$，可以将第 $i+1$ 个集合拆开，只留 $[0,m-\sum_{j=1}^i e_i]$（若 $m=\sum{j=1}^i e_i$，可以直接不要这个集合），那么前 $i+1$ 个集合的 $\text{mex}$ 和刚好为 $m$。  
至于多出来的东西，可以丢到前面的集合中让其重复，这样就不会对答案产生贡献了。~~（其实可以全都丢到 $e_1$，因为 $e_i$ 单调不增）~~

这个时候的答案就是 $i+[m=\sum_{j=1}^i e_i]$。  
时间复杂度 $O(T\max b_i)$，空间复杂度 $O(\max b_i)$。

---

很显然还没完事。。。  
上面做法的问题在于，最大化时一定会带来一堆重复的 $e_i$，不如开个 $f$，让 $f_i$ 表示 $e_i$ 有多少个，空间复杂度 $O(n)$。

时间上，这一坨 $\sum$ 显然是可以二分的，令 $h_i=\sum_{j=1}^i e_i\times f_i$，在 $h$ 中找到 $h_i\leq m$ 且 $h_{i+1} > m$ 的 $i$，再加上第 $i+1$ 块可能的数量，结果为：

::: center
$$
\left( \sum_{i=1}^n f_i\right)+\left\lceil \dfrac{m-h_i}{ e_{i+1} } \right\rceil
$$
:::

时间复杂度 $O(T\log n)$

::: warning
若 $m<e_1$，则应将 $e_1$ 拆成两半，即 $[0,m]$ 和 $[m+1,e_1-1]$
:::

## _Code_

还没写！