---
title: Luogu P14507 缺零分治 mexdnc
createTime: 2025/11/15 16:34:54
permalink: /blog/slz31tja/
tags:
    - Luogu
    - 贪心
---

## 题目大意  

[题目传送门](https://www.luogu.com.cn/problem/P14507)

给定正整数 $n$ 和 $n$ 个二元组 $(b_i,a_i)$，表示有 $b_i$ 个大小为 $a_i$ 的数。  
定义 $\text{mex}$ 表示一个集合中最小未出现的自然数。  
你需要将这 $\sum\limits_{i=1}^{n}b_i$ 个数分为 $k(k\geq 1)$ 个可重集合，使得这 $k$ 个集合的 $\text{mex}$ 和**恰好**为 $m$，求 $k$ 的最小值。  
给定 $T$ 组询问，每次给定一个 $m$，求最小的 $k$，若无解则输出 $-1$。

数据范围：  
$1\leq T\leq 10$  
$1\leq n,q\leq 10^5$  
$0\leq a_i\leq 10^9$ 且 $a_i<a_{i+1}$  
$1\leq b_i\leq 10^9$  
$1\leq m\leq 10^{18}$

## _Solution_

很容易注意到有些 $a_i$ 是没有用的，我们考虑如何将其去除。  
从题目中可以发现，$a_i$ 是升序给我们的，那么有用的 $a_i$ 一定是形如 ${0,1,...,x}$ 的一个排列。  
::: tip 结论
找到最小的 $i$ 使得 $a_i+1\neq a_{i+1}$（若不存在则 $i$ 为 $n$），则 $a_{i+1}$ 到 $a_n$ 都没有用
:::
我们令 $n$ 为上面的 $i$。
于是问题变成了对于 $i\in [1,n]$，有 $b_i$ 个 $i-1$。

---

先来考虑**无解**的情况，分讨一下有两种：
1. $m=0$，若 $n=0$，那么一定有一个集合被分到 $0$，即 $\text{mex}\geq 1$，总和一定不是 $0$，无解。  
2. 令目前所有数能凑出来的 $\text{mex}$ 的和的最大值为 $x$，若 $m>x$，则无解。  

---

考虑怎么求**最大和**：
* 一个集合中的所有数当且仅当出现一次，否则多余的数不产生贡献。
* 如果可以组成一个 $[0,u-1]$ 的序列，那么将其拆分为 $[0,v-1](v < u)$ 一定不优，因为 $[v,u-1]$ 被浪费了。

所以我们只需要每次找到**最大的** $u$ 满足可以构成 $[0,u-1]$ 的一个序列，产生 $u$ 的贡献，重复这个步骤就能得到最大值。

考虑怎么进行代码实现，我们令 $f_i=\min\limits_{j=1}^{i}b_j$，$g_i$ 为最小的满足 $b_j=f_i$ 的 $j$。
进行如下步骤：
1.  ==初始化==  
    初始时令 $p=n$，$d=0$（$p$ 为上面最大的 $u$，$d$ 为删掉的 $0$ 的个数）  
    由于删掉的 $0$ 的数其实就是序列总数，所以 $d$ 就是删除的序列数。
2.  ==计算贡献==  
    令 $c=f_p-d$ 即为能够取出多少个 $[0,p-1]$ 的序列，产生的贡献就是 $p\times c$。
3.  ==更新变量==  
    拿出 $c$ 个序列后，$d\leftarrow d+c$。  
    这个时候的 $g_p-1$ 已经用完（$g_p$ 在原数组对应 $g_p-1$ 这个数），所以 $g_p-1$ 到 $p-1$ 之间剩的数都没有用了，令 $p\leftarrow g_p-1$（注意这个时候指的是下标）
4.  ==完成==  
    重复这个步骤，直到 $p=0$。

这样我们得到了最大值。

::: details 如何计算 $f$ 和 $g$？
很明显要考虑递推。  
如果当前位置 $i$ 的 $b_i<f_{i-1}$，那么 $f_i=b_i$，$g_i=i$。  
如果当前位置 $i$ 的 $b_i\geq f_{i-1}$，那么 $f_i=f_{i-1}$，$g_i=g_{i-1}$
:::

这样，我们成功处理了无解的情况。

---

当前情况一定有解。  
我们把所有构成最大值的数组存下来，记作 $e$，则 $e_i$ 代表一个 $[0,e_i-1]$ 的序列。  
同时，为了用尽量少的集合，我们应该尽可能选择 $\text{mex}$ 大的集合。  
怎么选呢？事实上，$e_i$ 为**单调不增**的。  
这样就好办了，只需要每次找到一个 $i$ 满足 $\sum\limits_{j=1}^i e_i\leq m$ 且 $\sum\limits_{j=1}^{i+1} e_i>m$，则为了凑 $m$，可以将第 $i+1$ 个集合拆开，只留 $[0,m-\sum\limits_{j=1}^i e_i]$（若 $m=\sum\limits_{j=1}^i e_i$，可以直接不要这个集合），那么前 $i+1$ 个集合的 $\text{mex}$ 和刚好为 $m$。  
至于多出来的东西，可以丢到前面的集合中让其重复，这样就不会对答案产生贡献了。~~（其实可以全都丢到 $e_1$，因为 $e_i$ 单调不增）~~

这个时候的答案就是 $i+[m=\sum\limits_{j=1}^i e_i]$。  
时间复杂度 $O(T\max b_i)$，空间复杂度 $O(\max b_i)$。

---

很显然还没完事。。。  
上面做法的问题在于，最大化时一定会带来一堆重复的 $e_i$，不如开个 $f$，让 $f_i$ 表示 $e_i$ 有多少个，空间复杂度 $O(n)$。

时间上，这一坨 $\sum\limits$ 显然是可以二分的，令 $h_i=\sum\limits_{j=1}^i e_i\times f_i$，在 $h$ 中找到 $h_i\leq m$ 且 $h_{i+1} > m$ 的 $i$，再加上第 $i+1$ 块可能的数量，结果为：

::: center
$$
\left( \sum_{i=1}^n f_i\right)+\left\lceil \dfrac{m-h_i}{ e_{i+1} } \right\rceil
$$
:::

时间复杂度 $O(T\log n)$

::: warning
若 $m<e_1$，则应将 $e_1$ 拆成两半，即 $[0,m]$ 和 $[m+1,e_1-1]$  
若 $m=0$ 且 $n\neq 0$，请直接将所有询问判断完。**（被卡了好久）**
:::

## _Code_

```cpp :collapsed-lines
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>

using namespace std;

typedef long long LL;

struct Node {LL a , b; };

const int N = 1e5+10;

int n , q , cnt;
LL A[N] , B[N];
LL f[N] , g[N];
LL w[N] , sw[N] , sc[N];

void slove() {
	memset(w , 0 , sizeof w);
	memset(sw , 0 , sizeof sw);
	memset(sc , 0 , sizeof sc);
	memset(f , 0 , sizeof f);
	memset(g , 0 , sizeof g);
	scanf("%d%d" , &n , &q); cnt = 0;
	int tmp = n;
	for(int i = 1 ; i <= n ; i ++) {
		scanf("%lld%lld" , &A[i] , &B[i]);
		if(tmp == n && A[i] != i-1) {
			tmp = i-1;
		}
	}
	n = tmp;

    if(n == 0) {
        while(q --) {
            LL m; scanf("%lld" , &m);
            if(m) puts("-1");
            else puts("1");
        }
        return;
    }
	
	f[1] = B[1]; g[1] = 1;
	for(int i = 2 ; i <= n ; i ++) {
		f[i] = f[i-1]; g[i] = g[i-1];
		if(B[i] < f[i]) {
			f[i] = B[i];
			g[i] = i;
		}
	}
	
	int p = n; LL d = 0;
	while(p) {
		LL c = f[p]-d;
		
		++ cnt;
		w[cnt] = p;
		sc[cnt] = sc[cnt-1] + c;
		sw[cnt] = sw[cnt-1] + c*p;
		
		p = g[p]-1; d += c;
	}
	
	while(q --) {
		LL m; scanf("%lld" , &m);
		if((m == 0 && n != 0) || m > sw[cnt]) {
			puts("-1");
			continue;
		}
		if(m < w[1]) {
			puts("2");
			continue;
		}
		
		int l = 0 , r = cnt , mid , pos = 0;
		while(l <= r) {
			mid = (l+r) >> 1;
			if(sw[mid] <= m) {
				pos = mid;
				l = mid+1;
			} else {
				r = mid-1;
			}
		}
		
		LL res = 0;
		if(pos == 0) {
            res = (m+w[1]-1)/w[1];
		} else if(pos == cnt || sw[pos] == m) {
			res = sc[pos];
		} else if(w[pos+1] == 0) {
			res = sc[pos];
		} else {
			res = (m-sw[pos]+w[pos+1]-1)/w[pos+1]+sc[pos];
		}
		printf("%lld\n" , res);
	}
}

int main() {
	int T; scanf("%d" , &T);
	while(T --) slove();
	return 0;
}
```

## 后记
UPD 2025/11/21:
这个题实在太毒瘤了，边界情况超多。